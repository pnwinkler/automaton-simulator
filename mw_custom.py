# contains all custom code for mainwindow.
# the other file, "mainwindow_base.py", is purely Qt-generated.
# the reason they're kept separated is to separate the presentation from the behavior.
# this way, a new mockup can quickly and easily be exported from Designer into this project.

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QFont
from GUI_custom_scene import clickable_qgraphicsscene
from GUI_custom_ellipseitem import *
from generate_strings_from_regex import *
import automaton_logic as automaton_logic
import regex_generator as regex_generator
import resources.svg_paths as svg_paths
from collections import OrderedDict
from mainwindow_base import Ui_MainWindow
import PyQt5.QtWidgets
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtGui import QPen, QBrush
from PyQt5.QtWidgets import QGraphicsScene, QButtonGroup


# todo: figure out how to get clicks to work.
# this block is all placeholder
class custom_GraphicsScene(QGraphicsScene):
    def __init__(self, *args):
        super(custom_GraphicsScene, self).__init__(*args)
        self.setSceneRect(-100, -100, 200, 200)
        self.opt = ""

    def setOption(self, opt):
        self.opt = opt

    def mousePressEvent(self, event):
        pen = QPen(QtCore.Qt.black)
        brush = QBrush(QtCore.Qt.black)
        x = event.scenePos().x()
        y = event.scenePos().y()
        print(x, y)
        if self.opt == "Generate":
            self.addEllipse(x, y, 4, 4, pen, brush)
        elif self.opt == "Select":
            print(x, y)



class MW_Custom(Ui_MainWindow):
    def __init__(self, *args):
        # both lines seem to achieve the same thing
        Ui_MainWindow.__init__(object)
        Ui_MainWindow.setupUi(self,MainWindow)
        Ui_MainWindow.retranslateUi(self, MainWindow)
        # super(MW_Custom, self).__init__(*args)

        # we need a custom central widget in order to register clicks
        self.add_scene(custom_GraphicsScene)

        # set automaton variables
        # user_string holds the user's custom string, typically used in other functions to test automaton acceptance
        # (of the onscreen automaton)
        self.user_string = None

        # todo: revisit once state updating is complete. Is this a good idea?
        # whereas the self.user_string remains unchanged throughout, this string will be changed and printed
        # each step, to demonstrate the progress of the automaton (in the strikethrough area, right of user input)
        # self.progress_string = None

        # an index of our position in the user's string. Incremented as we progress the automaton,
        # decremented as we regress. Used for keeping track of current character for input processing
        self.index_in_user_str = 5

        # we don't create the automaton yet, because it will be created only when there's stuff to populate it with
        # it also allows for easier coding, where we can just check if not self.automaton:...
        # and can be used to ensure a singleton
        self.automaton = None

        # used by self.updateAutomatonFromAutomatonBoard() to see if changes have been made
        # todo: rename that function. Also, does it make sense for this to be here? Should this be a property of
        #  the Automaton object?
        self.previous_board = None

        # the regex problem for the user to solve. Appears in the top left.
        self.regex_to_solve = None

    def add_scene(self, custom_GraphicsScene):
        self.scene = custom_GraphicsScene(QGraphicsScene(self.centralwidget))
        # print(self, type(self))
        # print(self.scene, type(self.scene))
        # print(self.centralwidget)
        self.graphicsView.setScene(self.scene)

    def setupUi(self, MainWindow):
        super(MW_Custom, self).setupUi(MainWindow)

    def renameGuiElements(self):
        # Alias long names, and indicate which elements are okay to modify.
        # ui_ indicates items generated by Qt, and mw_ items that I'm modifying
        # so when I see a ui_ item elsewhere, I know not to modify it
        self.mw_problem_to_solve_lbl = self.ui_problem_to_solve_tooltip_label
        self.mw_user_string_accepted_or_rejected_lbl = self.ui_input_accepted_or_rejected_label
        self.mw_enter_string_to_test_lineedit = self.ui_take_string_to_test_lineedit
        self.mw_easy_pushbtn = self.ui_difficulty_easy_pushButton
        self.mw_med_pushbtn = self.ui_difficulty_medium_pushButton
        self.mw_hard_pushbtn = self.ui_difficulty_hard_pushButton
        self.mw_hint_pushbtn = self.ui_request_hint_pushButton
        self.mw_submit_pushbtn = self.ui_submit_solution_pushButton
        self.mw_toggle_solution_pushbtn = self.ui_toggle_solution_pushButton
        self.mw_skip_to_begin_pushbtn = self.ui_skip_to_start_pushButton
        self.mw_step_backwards_pushbtn = self.ui_skip_back_one_step_pushButton
        self.mw_step_forwards_pushbtn = self.ui_skip_forward_one_step_pushButton
        self.mw_skip_to_end_pushbtn = self.ui_skip_to_end_pushButton

        # replace placeholder text
        # the label below the user input field
        self.ui_input_accepted_or_rejected_label.setText("")
        self.mw_acc_or_rej_lbl = self.ui_input_accepted_or_rejected_label

        # the live summary, to the right of the user input field
        self.ui_live_input_proc_summary_label.setText("")
        self.mw_live_summary_lbl = self.ui_live_input_proc_summary_label


    def linkButtonsWithFunctions(self):
        # generate a problem and write to the appropriate label (top left)
        self.mw_easy_pushbtn.clicked.connect(self.requestProblemEasy)
        self.mw_med_pushbtn.clicked.connect(self.requestProblemMedium)
        self.mw_hard_pushbtn.clicked.connect(self.requestProblemHard)

        # accept a user's string, that other functions may use to test the automaton
        self.mw_enter_string_to_test_lineedit.editingFinished.connect(self.takeStringToTest)

        # generate a hint
        self.mw_hint_pushbtn.clicked.connect(self.generateHint)

        # let user submit solution, then test it and do whatever else necessary
        self.mw_submit_pushbtn.clicked.connect(self.acceptSubmission)

        # toggle the solution
        self.mw_toggle_solution_pushbtn.clicked.connect(self.toggleSolution)

        # playback control
        self.mw_skip_to_begin_pushbtn.clicked.connect(self.skipToBegin)
        self.mw_step_backwards_pushbtn.clicked.connect(self.stepBackwards)
        self.mw_step_forwards_pushbtn.clicked.connect(self.stepForwards)
        self.mw_skip_to_end_pushbtn.clicked.connect(self.skipToEnd)

    def toggleSolution(self):
        # toggle hides the user's automaton and shows a solution in its place
        print("toggleSolution() not yet implemented")

    def takeStringToTest(self):
        # called when user finishes editing self.mw_enter_string_to_test_lineedit
        # that means either hitting "Enter", or typing something then clicking away, or both.
        entered = self.mw_enter_string_to_test_lineedit.text()
        if self.user_string != entered:
            # we don't want to be notified twice, assuming the user presses enter then clicks away
            self.user_string = self.mw_enter_string_to_test_lineedit.text()
            self.mw_live_summary_lbl.setText("Entered:  " + self.user_string)
            print(f"User string \"{self.user_string}\" saved")

    def updateAutomatonFromAutomatonBoard(self):
        # looks to self.mw_central_graphicsScene.automaton_board to determine the
        # properties of the board that the user wishes to create
        # then interprets automaton_board in order to create the objects and transitions
        # in automaton_logic.py
        # when I have time, I might write a more efficient solution
        # given limited time, this is the fastest-to-write, least error-prone solution I could come up with

        # we use deepcopy because automaton_board is a dict and is therefore passed by reference
        # but we don't want to change it here
        self.automaton = automaton_logic.Automaton()
        # received_board = deepcopy(self.mw_central_graphicsScene.automaton_board)

        # we use an OrderedDict so that that our automaton nodes in node_lst will have their indexes match
        # those of states_to_add (in block below)
        received_board = OrderedDict(self.mw_central_graphicsScene.automaton_board)

        # print("received board", received_board)
        states_to_add = received_board.keys()

        # create a list of nodes, so that they are all created and useable as target states
        # for when we want to have them be target nodes for transitions
        node_lst = []
        for s in states_to_add:
            node_lst.append(self.automaton.addStateReturnID())

        # print("DEBUG: received board", received_board)

        # use an index to iterate through the newly-created nodes, as well as the values in
        # received_board, which as an OrderedDict, will retain order.
        for x in range(len(states_to_add)):
            # use this index for both list and dict
            # to create transitions
            # for values in the .get stuff
            originating_node = node_lst[x]

            # get is the value for each key in order, in received_board
            get = list(received_board.values())[x]
            # print("debug: get=", get)

            if not get:
                # there's no value registered for that state. i.e. no outbound to add
                continue

            # set properties, such as accepting or initial
            # and shorten get accordingly, removing 'a'/'i' this signals
            if get[0] == 'a':
                self.automaton.flipAcceptingOrRejecting(originating_node)
            elif get[1] == 'i':
                self.automaton.setInitialNode(originating_node)

            try:
                if get[1] == 'a':
                    self.automaton.flipAcceptingOrRejecting(originating_node)
                if get[1] == 'i':
                    self.automaton.setInitialNode(originating_node)
            except IndexError:
                pass

            if self.automaton.initial_node_obj == self.automaton.takeIDReturnNodeObject(originating_node):
                # we set it to be initial, so we remove a leading (which will be either a or i)
                get = get[1:]
            if self.automaton.takeIDReturnNodeObject(originating_node).accepting:
                # we set it to be initial, so we remove a leading letter (which will be either a or i)
                get = get[1:]

            # for the values at that key
            for c in get:
                if c == "Q" or c == 'i':
                    # don't add the state name to transitions
                    pass
                elif c.isdigit():
                    # it's the numeric portion of our target state's identifier (e.g. Q3)
                    # we save it in the N1__ format, just in case we need to find it in our automaton states
                    target_state = "N10" + c
                else:
                    # add the transition letter to transitions
                    self.automaton.addTransition(originating_node, target_state, c)
                    # print(f"info: adding transition {c}")
        # print("States and transitions added to automaton")
        print("Automaton updated")
        print("Nodes in automaton", [node.identifier for node in self.automaton.node_collection])
        for node in self.automaton.node_collection:
            print(f"\tNode {node.identifier}, with outbound transitions: {node.outbound_transitions}")

    def updateAutomatonBoard(self):
        # I don't think we need this automaton_board doesn't do anything within the program,
        # it's just for external use. If we need to change the appearance of its items, I think we can just
        # call them directly, or make a new function in GUI_..py and call that (for example to scale an item)
        pass

    def generateProblemToSolve(self, requested_difficulty):
        # called by the 3 functions below.
        # randomly generates a problem for the user to solve
        # then writes it to the label
        self.regex_to_solve = regex_generator.generateRegex(requested_difficulty)
        self.mw_problem_to_solve_lbl.setText("Problem to solve: " + self.regex_to_solve)
        self.mw_problem_to_solve_lbl.setFont(QFont("Arial", 12))

    def requestProblemEasy(self):
        self.generateProblemToSolve('easy')

    def requestProblemMedium(self):
        self.generateProblemToSolve('medium')

    def requestProblemHard(self):
        self.generateProblemToSolve('hard')

    def generateHint(self):
        if not self.automaton:
            print("Cannot provide hint: no automaton recognized yet. Please create one")
            return -1
        if not self.regex_to_solve:
            print("Cannot provide hint: there's no regex to solve")
            return -1
        self.determinePassed(generate_hint=True)

    def determinePassed(self, generate_hint=False):
        # we should test the current automaton (without using GUI elements), on a variety of strings
        # if it passes a string in the fail category, or fails one in the pass category, we write that
        # to the hint label

        # if not self.automaton:
        #     print("No automaton recognized yet. Please create one")
        #     return -1
        # if not self.regex_to_solve:
        #     print("Can't accept submission: there's no regex to solve")
        #     return -1

        # returns 2 lists, first of pass strings, second of fail strings. Both sorted by shortest first
        pass_list, fail_list = generate_Strings_from_reg(self.regex_to_solve)

        # needs an input string. Returns True if the whole thing is accepted, False if it's rejected
        for p in pass_list:
            passed = self.automaton.determineWholeInputAcceptance(p)
            if not passed:
                if generate_hint:
                    print(f"Hint: \"{p}\" should not pass")
                    self.mw_hint_pushbtn.setText(p)
                return False
        for f in fail_list:
            failed = self.automaton.determineWholeInputAcceptance(f)
            if not failed:
                print(f"Hint: \"{f}\" should not pass")
                self.mw_hint_pushbtn.setText(p)
                return False
        # print("Automaton fully correct! No hint to give")
        return True

    def acceptSubmission(self):
        # this handles hints. If it returns true we say ACCEPTED, else REJECTED
        # this way we automatically generate hints for the user
        if not self.automaton:
            print("Cannot accept submission: no automaton recognized yet. Please create one")
            return
        if not self.regex_to_solve:
            print("Cannot accept submission: there's no regex to solve")
            return

        # self.mw_submit_pushbtn.setStyleSheet('QPushButton {background-color: #A3C1DA; color: red;}')
        passed = self.determinePassed()
        if passed:
            self.mw_submit_pushbtn.setStyleSheet('QPushButton {color: green;}')
            self.mw_submit_pushbtn.setText("ACCEPTED")
        else:
            self.mw_submit_pushbtn.setStyleSheet('QPushButton {color: red;}')
            self.mw_submit_pushbtn.setText("REJECTED")

    def updateAutomaton(self):
        # after a user submitted / gave up, this function
        # lets them switch between viewing their submission
        # and the generated solution
        self.updateAutomatonFromAutomatonBoard()
        # print('Updated automaton')
        # return 'PLACEHOLDER toggle()'

    def skipToBegin(self):
        # recreate the automaton or regressToStart(),
        # reset indexes,
        # clear the history and current lines
        # clear accepted / rejected label
        # reset hint button
        # reset submit button
        if not self.automaton:
            print("No active automaton.")
            return

        self.automaton.regressToStart()
        self.index_in_user_str = 0
        self.mw_acc_or_rej_lbl.setText("")
        self.mw_previous_line_lbl.setText("")
        self.mw_user_string_accepted_or_rejected_lbl.setText("")
        self.mw_hint_pushbtn.setText("Hint")
        self.mw_submit_pushbtn.setText("Submit")

        print('skipped to beginning')

    def stepBackwards(self):
        # it's faster to recompute from the start than actually undo a step
        len_contents_before = len(self.mw_acc_or_rej_lbl.text())
        if len_contents_before == 0:
            print("Can't undo. No prior operations committed.")
            return -1

        self.skipToBegin()
        while len(self.mw_acc_or_rej_lbl.text()) != len_contents_before + 1:
            retval = self.stepForwards()
            if retval == -1:
                # otherwise we get "No valid automaton" spam
                break

    def stepForwards(self):
        if not self.automaton:
            print("Cannot step forwards: no valid automaton")
            return -1
        if not self.user_string:
            print("Cannot step forwards: no user string provided")
            return -1

        try:
            # NOTE: the index is handled in the self.progressLiveFeed() function
            accepting = self.automaton.progressOneStep(self.user_string[self.index_in_user_str])
        except IndexError:
            # string is exhausted. We test whether the current node is accepting or rejecting
            accepting = self.automaton.progressOneStep("")
            if accepting:
                self.mw_user_string_accepted_or_rejected_lbl.setText("ACCEPTED")
            else:
                self.mw_user_string_accepted_or_rejected_lbl.setText("REJECTED")

        if not accepting:
            self.mw_user_string_accepted_or_rejected_lbl.setText("rejecting...")
            return False
        else:
            self.mw_user_string_accepted_or_rejected_lbl.setText("accepting...")
            self.progressLiveFeed()
            return True

    def skipToEnd(self):
        # the +1 is important! We use it to test whether the automaton accepts "" at the end of the string
        # i.e. is the final state accepting?
        if self.user_string is not None:
            for c in range(len(self.user_string) + 1):
                self.stepForwards()
        else:
            # I don't think we need to show this to the user within the GUI right?
            # actually, at some point it's worth doing so. Just create a short-lived label
            # that draws their attention, then disappears
            print("Cannot progress automaton. No user string provided to test against.")

    def progressLiveFeed(self):
        # updates the "live" processing area, below the box where the user entered the string.
        # this moves characters, bolds them, strikes them through, each run.

        if self.index_in_user_str == 0:
            # we are just starting
            curr_text = self.mw_live_summary_lbl.text()

            # get rid of initial tabs
            curr_text.replace("\t", "").replace("\t", "")

            # set topmost label, right of centre screen, on the bottom portion of the screen
            # to equal the newly-entered user string
            self.index_in_user_str += 1
            curr_text = self.user_string[self.index_in_user_str:]
            self.mw_acc_or_rej_lbl.setText('\n' + curr_text)

            # clear past history (there shoudn't be any anyway)
            self.mw_previous_line_lbl.setText("")
        else:
            if self.index_in_user_str == len(self.user_string) - 1:
                previous_content_of_current_line_lbl = self.mw_acc_or_rej_lbl.text()

                print("User string exhausted. No more input to process")
                self.mw_acc_or_rej_lbl.setText("ε")

                updated_history = previous_content_of_current_line_lbl + self.mw_previous_line_lbl.text()
                self.mw_previous_line_lbl.setText(updated_history)

                # prompts self.stepForwards() to continue, and process the empty string
                self.index_in_user_str += 1
                return

            self.mw_acc_or_rej_lbl.setFont(QFont("Arial", 12))
            self.index_in_user_str += 1
            previous_content_of_current_line_lbl = self.mw_acc_or_rej_lbl.text()
            self.mw_acc_or_rej_lbl.setText("\n" + self.user_string[self.index_in_user_str:])
            print("info: remainder of user string:", self.user_string[self.index_in_user_str:])

            # we always prepend to mw_previous_line_lbl
            updated_history = previous_content_of_current_line_lbl + self.mw_previous_line_lbl.text()
            self.mw_previous_line_lbl.setText(updated_history)


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = MW_Custom()  # class object
    ui.setupUi(MainWindow)  # class function. basically an __init__

    # do remaining setup (linking etc)
    ui.renameGuiElements()
    ui.linkButtonsWithFunctions()

    MainWindow.show()
    sys.exit(app.exec_())